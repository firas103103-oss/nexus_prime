import { GoogleGenAI, Type, Chat } from "@google/genai";
import { EditingStyle, EditingIntensity, CustomEditingPreferences, Language, AspectRatio, BookMetadata, ProcessingStatus, PrimaryGoal } from "../types";
import { chunkTextSmart, mergeEditedChunks, validateEditedLength, countWords, calculateProgress, SmartChunk } from "../utils/textChunking";

// ===== TYPES =====

/**
 * Result Type - نمط موحد لإرجاع النتائج
 * يضمن تعامل متسق مع الأخطاء في جميع الدوال
 */
export type Result<T> = 
  | { success: true; data: T }
  | { success: false; error: string; code?: string };

/**
 * Helper لإنشاء نتيجة ناجحة
 */
export const ok = <T>(data: T): Result<T> => ({ success: true, data });

/**
 * Helper لإنشاء نتيجة فاشلة
 */
export const err = <T>(error: string, code?: string): Result<T> => ({ 
  success: false, 
  error, 
  code 
});

// الحصول على API Key من متغيرات البيئة (Vite يعرّفه في vite.config.ts)
const API_KEY = process.env.API_KEY || process.env.GEMINI_API_KEY || '';

if (!API_KEY) {
  console.error('⚠️ GEMINI_API_KEY is missing! Please check your .env file.');
  throw new Error('GEMINI_API_KEY is not defined. Please add it to your .env file.');
}

const ai = new GoogleGenAI({ apiKey: API_KEY });

// --- Model Configuration ---
const MODEL_FAST = 'gemini-flash-lite-latest'; 
const MODEL_STANDARD = 'gemini-3-flash-preview';
const MODEL_THINKING = 'gemini-3-pro-preview';
const MODEL_IMAGE = 'gemini-3-pro-image-preview';

// --- Retry Helper ---
const retryWithBackoff = async <T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> => {
  let lastError: Error | null = null;
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error: any) {
      lastError = error;
      console.warn(`Attempt ${i + 1} failed: ${error.message}`);
      if (i < maxRetries - 1) {
        const delay = baseDelay * Math.pow(2, i);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  throw lastError;
};

// --- Helpers ---
const cleanAndParseJSON = (text: string, fallback: any) => {
  try {
    if (!text) return fallback;
    const clean = text.replace(/```json\n?|```\n?|```/g, '').trim();
    return JSON.parse(clean);
  } catch (e) {
    return fallback;
  }
};

const getSystemInstruction = (lang: Language): string => {
  switch (lang) {
    case 'en': return "You are 'The Seventh Shadow', an elite Senior Editor AI Agent for MrF X OS Organization. Professional, concise, authoritative yet helpful.";
    case 'de': return "Sie sind 'Der Siebte Schatten', ein Elite-KI-Lektor für MrF X OS Organization. Professionell, präzise und hilfreich.";
    default: return "أنت 'الظل السابع'، وكيل نشر ذكي ونخبي يمثل منظمة MrF X OS. أسلوبك احترافي، بليغ، حازم ولكن متعاون. هدفك الوصول لأعلى جودة.";
  }
};

// --- New Feature: Input Validation Agent ---
export const validateUserInput = async (input: string, context: string, lang: Language): Promise<{ isValid: boolean; corrected?: string; reason?: string }> => {
    // Uses the fastest model to check logic
    const prompt = `
    Context: user is inputting data for publishing workflow. 
    Field expected: ${context}.
    User Input: "${input}".
    
    Task: 
    1. Is this valid input for the field? (e.g. if asking for email, is it an email? if asking for name, is it a name not gibberish?)
    2. If valid but needs slight formatting (e.g. capitalization), provide corrected version.
    
    Output JSON: { "isValid": boolean, "corrected": string, "reason": string }
    `;

    try {
        const response = await ai.models.generateContent({
            model: MODEL_FAST,
            contents: [{ text: prompt }],
            config: { responseMimeType: "application/json" }
        });
        return cleanAndParseJSON(response.text || "{}", { isValid: true, corrected: input });
    } catch (e) {
        return { isValid: true, corrected: input }; // Fail open if AI fails
    }
};

// --- Core Services ---

/**
 * تحليل المخطوطة الشامل - يدعم ملفات حتى 150k+ كلمة
 * بدلاً من أخذ عينة، نقوم بتحليل كل الأجزاء مع تلخيص تدريجي
 */
export const analyzeManuscriptScalable = async (
  text: string, 
  meta: BookMetadata,
  onProgress?: (status: ProcessingStatus) => void
): Promise<{ analysis: string, legalReport: string, editorNotes: string }> => {
  
  const totalWords = countWords(text);
  
  // للملفات الصغيرة (أقل من 100k حرف)، تحليل مباشر
  if (text.length <= 100000) {
    onProgress?.({
      stage: 'analyzing',
      progress: 50,
      message: 'جاري التحليل الأدبي والقانوني...'
    });

    const prompt = `
    Analyze this manuscript for MrF X OS Organization.
    Metadata: Title="${meta.title}", Author="${meta.author}", Genre="${meta.genre}".
    Target: ${meta.targetRegion}, Audience: ${meta.targetAudience}.
    Total Words: ${totalWords}
    
    Output JSON:
    1. analysis: Literary critique (Plot, Pacing, Characters, Structure).
    2. legalReport: Compliance check for ${meta.targetRegion} (Censorship, Copyright risks).
    3. editorNotes: Actionable improvements for author ${meta.userName}.
    `;

    const response = await ai.models.generateContent({
      model: MODEL_THINKING,
      contents: [
          { text: prompt },
          { text: text } 
      ],
      config: {
        systemInstruction: getSystemInstruction(meta.language),
        responseMimeType: "application/json",
        thinkingConfig: { thinkingBudget: 32768 },
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            analysis: { type: Type.STRING },
            legalReport: { type: Type.STRING },
            editorNotes: { type: Type.STRING }
          }
        }
      }
    });

    onProgress?.({
      stage: 'analyzing',
      progress: 100,
      message: 'اكتمل التحليل!'
    });

    return cleanAndParseJSON(response.text || "{}", {
      analysis: "Analysis failed.", legalReport: "Check manually.", editorNotes: "Check manually."
    });
  }

  // للملفات الكبيرة: تحليل تدريجي بالأجزاء
  onProgress?.({
    stage: 'analyzing',
    progress: 10,
    message: `جاري تقسيم المخطوطة (${totalWords.toLocaleString()} كلمة)...`
  });

  const chunks = chunkTextSmart(text, 80000, 1000);
  const partialAnalyses: string[] = [];
  const legalIssues: string[] = [];
  const editorNotesAll: string[] = [];

  for (let i = 0; i < chunks.length; i++) {
    const progress = 10 + ((i / chunks.length) * 60); // 10% to 70%
    onProgress?.({
      stage: 'analyzing',
      progress: Math.round(progress),
      currentChunk: i + 1,
      totalChunks: chunks.length,
      message: `تحليل القسم ${i + 1} من ${chunks.length}...`
    });

    const chunkPrompt = `
    Analyze Part ${i + 1}/${chunks.length} of manuscript "${meta.title}".
    Total Words in Part: ${countWords(chunks[i].text)}
    
    Provide:
    1. partialAnalysis: Key observations about this section (plot, character development, pacing).
    2. legalIssues: Any potential legal/censorship concerns for ${meta.targetRegion}.
    3. editorNotes: Specific improvement suggestions for this section.
    
    Output JSON with these 3 fields.
    `;

    try {
      const response = await ai.models.generateContent({
        model: MODEL_STANDARD, // استخدام النموذج القياسي للتحليل الجزئي
        contents: [
          { text: chunkPrompt },
          { text: chunks[i].text }
        ],
        config: {
          systemInstruction: getSystemInstruction(meta.language),
          responseMimeType: "application/json",
          responseSchema: {
            type: Type.OBJECT,
            properties: {
              partialAnalysis: { type: Type.STRING },
              legalIssues: { type: Type.STRING },
              editorNotes: { type: Type.STRING }
            }
          }
        }
      });

      const parsed = cleanAndParseJSON(response.text || "{}", {
        partialAnalysis: "",
        legalIssues: "",
        editorNotes: ""
      });

      partialAnalyses.push(parsed.partialAnalysis);
      legalIssues.push(parsed.legalIssues);
      editorNotesAll.push(parsed.editorNotes);

    } catch (e) {
      console.error(`Failed to analyze chunk ${i}`, e);
      partialAnalyses.push(`[Section ${i + 1} analysis failed]`);
    }
  }

  // دمج التحليلات الجزئية في تقرير شامل
  onProgress?.({
    stage: 'analyzing',
    progress: 85,
    message: 'دمج التحليلات وإنشاء التقرير النهائي...'
  });

  const synthesisPrompt = `
  Synthesize ${partialAnalyses.length} partial analyses into ONE comprehensive final report.
  
  Partial Analyses:
  ${partialAnalyses.map((a, i) => `\n--- Part ${i + 1} ---\n${a}`).join('\n')}
  
  Output JSON:
  1. analysis: Comprehensive literary analysis (overall plot, character arcs, pacing, themes).
  2. legalReport: Combined legal/censorship assessment for ${meta.targetRegion}.
  3. editorNotes: Prioritized actionable recommendations for author ${meta.userName}.
  `;

  const finalResponse = await ai.models.generateContent({
    model: MODEL_THINKING,
    contents: [
      { text: synthesisPrompt },
      { text: `Legal Issues Found:\n${legalIssues.join('\n\n')}` },
      { text: `Editor Notes:\n${editorNotesAll.join('\n\n')}` }
    ],
    config: {
      systemInstruction: getSystemInstruction(meta.language),
      responseMimeType: "application/json",
      thinkingConfig: { thinkingBudget: 16384 },
      responseSchema: {
        type: Type.OBJECT,
        properties: {
          analysis: { type: Type.STRING },
          legalReport: { type: Type.STRING },
          editorNotes: { type: Type.STRING }
        }
      }
    }
  });

  onProgress?.({
    stage: 'analyzing',
    progress: 100,
    message: 'اكتمل التحليل الشامل!'
  });

  return cleanAndParseJSON(finalResponse.text || "{}", {
    analysis: partialAnalyses.join('\n\n'),
    legalReport: legalIssues.join('\n\n'),
    editorNotes: editorNotesAll.join('\n\n')
  });
};

/**
 * تحرير المخطوطة الذكي - يدعم ملفات ضخمة مع الحفاظ على كل الكلمات
 * يتضمن خيارات تحرير متقدمة وتفضيلات مخصصة
 */
export const editManuscriptSmart = async (
  text: string,
  meta: BookMetadata,
  intensityOverride?: EditingIntensity,
  customOptions?: any,
  onProgress?: (status: ProcessingStatus) => void
): Promise<string> => {
  const totalWords = countWords(text);
  const editingIntensity = intensityOverride || meta.editingIntensity || EditingIntensity.MODERATE;
  
  onProgress?.({
    stage: 'editing',
    progress: 5,
    message: `جاري تحضير التحرير (${totalWords.toLocaleString()} كلمة)...`
  });

  const chunks = chunkTextSmart(text, 75000, 1000); // حجم أصغر قليلاً للتحرير
  const editedChunks: string[] = [];

  // بناء prompt مخصص بناءً على التفضيلات
  const intensityInstructions: Record<string, string> = {
    light: "Make minimal edits: fix only grammar, spelling, and punctuation errors. Preserve original style completely.",
    moderate: "Moderate editing: fix errors, improve sentence flow, enhance clarity. Keep the author's voice.",
    deep: "Deep editing: comprehensive improvements to grammar, style, structure, and flow. Maintain core meaning.",
    preserve_voice: "Priority: PRESERVE the author's unique voice and style. Focus only on technical improvements."
  };

  let customInstructions = '';
  const prefs = customOptions || meta.customPreferences;
  if (editingIntensity === EditingIntensity.PRESERVE_VOICE && prefs) {
    customInstructions = `
    Custom Preferences:
    - Dialogue Style: ${prefs.preserveDialogueStyle ? 'PRESERVE EXACTLY' : 'can improve'}
    - Narrative Tone: ${prefs.preserveNarrativeTone ? 'PRESERVE EXACTLY' : 'can enhance'}
    - Descriptions: ${prefs.enhanceDescriptions ? 'ENHANCE and enrich' : 'minimal changes'}
    - Structure: ${prefs.improveStructure ? 'IMPROVE organization' : 'keep as-is'}
    ${prefs.focusAreas?.length ? `- Focus Areas: ${prefs.focusAreas.join(', ')}` : ''}
    ${prefs.avoidChangingElements?.length ? `- DO NOT CHANGE: ${prefs.avoidChangingElements.join(', ')}` : ''}
    `;
  }

  const promptBase = `
  Role: Elite Editor for MrF X OS Organization.
  Task: Edit the following text segment with EXTREME CARE.
  
  Editing Style: ${meta.style}
  Intensity: ${meta.editingIntensity} - ${intensityInstructions[meta.editingIntensity]}
  ${customInstructions}
  
  CRITICAL RULES:
  1. Output length MUST be similar to input (±5% word count tolerance).
  2. Maintain ALL formatting (paragraphs, spacing, line breaks).
  3. Keep the semantic meaning and content integrity.
  4. For "preserve_voice" mode: Make NO stylistic changes, only technical fixes.
  
  Output: The edited text ONLY, nothing else.
  `;

  // معالجة تسلسلية مع دمج سلس
  for (let i = 0; i < chunks.length; i++) {
    const progress = 5 + ((i / chunks.length) * 85); // 5% to 90%
    onProgress({
      stage: 'editing',
      progress: Math.round(progress),
      currentChunk: i + 1,
      totalChunks: chunks.length,
      message: `تحرير القسم ${i + 1} من ${chunks.length} (${Math.round((i/chunks.length)*100)}%)`
    });
    
    try {
      // إضافة context من الـ chunk السابق واللاحق للحفاظ على الانسيابية
      let contextualPrompt = promptBase;
      if (i > 0 && chunks[i].metadata.overlapStart) {
        contextualPrompt += `\n\nContext from previous section (for continuity, DO NOT edit):\n"...${chunks[i].metadata.overlapStart}"`;
      }
      if (i < chunks.length - 1 && chunks[i].metadata.overlapEnd) {
        contextualPrompt += `\n\nContext from next section (for continuity, DO NOT edit):\n"${chunks[i].metadata.overlapEnd}..."`;
      }

      const response = await ai.models.generateContent({
        model: MODEL_STANDARD,
        contents: [
          { text: contextualPrompt },
          { text: chunks[i].text }
        ],
        config: {
          systemInstruction: getSystemInstruction(meta.language),
        }
      });

      const editedText = response.text || chunks[i].text;
      
      // التحقق من طول الجزء المحرر
      const originalWords = countWords(chunks[i].text);
      const editedWords = countWords(editedText);
      const ratio = (editedWords / originalWords) * 100;
      
      if (Math.abs(100 - ratio) > 15) {
        console.warn(`Chunk ${i + 1}: Length mismatch (${ratio.toFixed(1)}%), using original`);
        editedChunks.push(chunks[i].text);
      } else {
        editedChunks.push(editedText);
      }

    } catch (e) {
      console.error(`Chunk ${i + 1} edit failed:`, e);
      editedChunks.push(chunks[i].text); // Fallback
    }
  }

  onProgress({
    stage: 'editing',
    progress: 95,
    message: 'دمج الأجزاء المحررة بسلاسة...'
  });

  // دمج الأجزاء مع إصلاح الحدود
  const finalEditedText = mergeEditedChunks(editedChunks);

  // التحقق النهائي من الطول
  const validation = validateEditedLength(text, finalEditedText, 10);
  console.log('Final validation:', validation.message);

  onProgress({
    stage: 'editing',
    progress: 100,
    message: `اكتمل التحرير! ${validation.message}`
  });

  return finalEditedText;
};

export const generateBookExtras = async (text: string, meta: BookMetadata): Promise<any> => {
  const prompt = `
  Generate marketing assets for book "${meta.title}".
  Author: ${meta.author}.
  Output JSON: dedication, aboutAuthor, synopsis (200 words), suggestedBlurb (Back cover hook).
  `;

  const response = await ai.models.generateContent({
    model: MODEL_STANDARD,
    contents: [text.substring(0, 30000) + "\n\n" + prompt], 
    config: {
      systemInstruction: getSystemInstruction(meta.language),
      responseMimeType: "application/json",
      responseSchema: {
        type: Type.OBJECT,
        properties: {
          dedication: { type: Type.STRING },
          aboutAuthor: { type: Type.STRING },
          synopsis: { type: Type.STRING },
          suggestedBlurb: { type: Type.STRING },
        }
      }
    }
  });

  return cleanAndParseJSON(response.text || "{}", {});
};

export const generateCoverImage = async (
  description: string, 
  title: string, 
  aspectRatio: AspectRatio
): Promise<string> => {
  const prompt = `High-end Book Cover Art. Title: "${title}". Description: ${description}. No text overlay. Cinematic lighting, 8k, photorealistic or stylized as requested.`;
  
  try {
    const response = await ai.models.generateContent({
      model: MODEL_IMAGE,
      contents: { parts: [{ text: prompt }] },
      config: {
        imageConfig: { aspectRatio: aspectRatio, imageSize: "1K" }
      }
    });

    if (response.candidates?.[0]?.content?.parts) {
        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData && part.inlineData.data) {
                return part.inlineData.data;
            }
        }
    }
    console.warn('No image data found in Imagen response');
    return "";
  } catch (e: any) {
    console.error('Cover generation failed:', {
      error: e.message,
      statusCode: e.status,
      model: MODEL_IMAGE
    });
    return "";
  }
};

// ===========================================
// PRIMARY GOAL PROCESSING
// ===========================================

/**
 * generatePreface - إنشاء مقدمة احترافية للكتاب
 */
export const generatePreface = async (metadata: BookMetadata, mainText: string): Promise<string> => {
  const lang = metadata.language;
  const prompt = `
  You are a professional book editor. Create a compelling **preface** for this book:
  
  Title: ${metadata.title}
  Author: ${metadata.author}
  Genre: ${metadata.genre}
  Target Audience: ${metadata.targetAudience}
  Key Themes: ${metadata.keyThemes}
  
  Context from manuscript (first 3000 characters):
  ${mainText.substring(0, 3000)}
  
  Write a 400-600 word preface in ${lang === 'ar' ? 'Arabic' : lang === 'en' ? 'English' : 'German'}.
  The preface should:
  - Welcome the reader
  - Explain the book's purpose and importance
  - Preview key insights
  - Build anticipation
  
  Output ONLY the preface text, no markdown formatting.
  `;
  
  try {
    const response = await ai.models.generateContent({
      model: MODEL_THINKING,
      contents: { parts: [{ text: prompt }] },
      config: { 
        systemInstruction: getSystemInstruction(lang),
        thinkingConfig: { thinkingBudget: 8192 }
      }
    });
    return response.text || "";
  } catch (e) {
    console.error('Preface generation failed:', e);
    return "";
  }
};

/**
 * generateTableOfContents - إنشاء فهرس تلقائي
 */
export const generateTableOfContents = async (metadata: BookMetadata, mainText: string): Promise<string> => {
  const lang = metadata.language;
  const prompt = `
  Analyze this manuscript and create a **Table of Contents** with chapter titles:
  
  Manuscript:
  ${mainText.substring(0, 10000)}
  
  Extract or infer chapter/section titles. Format as:
  ${lang === 'ar' ? 'الفهرس\n\nالفصل الأول: [عنوان]\nالفصل الثاني: [عنوان]' : 'TABLE OF CONTENTS\n\nChapter 1: [Title]\nChapter 2: [Title]'}
  
  Language: ${lang === 'ar' ? 'Arabic' : lang === 'en' ? 'English' : 'German'}
  `;
  
  try {
    const response = await ai.models.generateContent({
      model: MODEL_STANDARD,
      contents: { parts: [{ text: prompt }] }
    });
    return response.text || "";
  } catch (e) {
    console.error('TOC generation failed:', e);
    return "";
  }
};

/**
 * generateReferences - إنشاء قائمة مراجع
 */
export const generateReferences = async (metadata: BookMetadata, mainText: string): Promise<string> => {
  const lang = metadata.language;
  const prompt = `
  Based on this book's content and themes, suggest 8-12 relevant **references** (books, articles, sources):
  
  Genre: ${metadata.genre}
  Key Themes: ${metadata.keyThemes}
  Sample Content:
  ${mainText.substring(0, 5000)}
  
  Format as:
  ${lang === 'ar' ? 'المراجع\n\n1. [اسم المرجع] - [المؤلف]\n2. ...' : 'REFERENCES\n\n1. [Reference Title] - [Author]\n2. ...'}
  
  Language: ${lang}
  `;
  
  try {
    const response = await ai.models.generateContent({
      model: MODEL_STANDARD,
      contents: { parts: [{ text: prompt }] }
    });
    return response.text || "";
  } catch (e) {
    return "";
  }
};

/**
 * generateIndex - إنشاء فهرس موضوعي
 */
export const generateIndex = async (metadata: BookMetadata, mainText: string): Promise<string> => {
  const lang = metadata.language;
  const prompt = `
  Create an **alphabetical index** of key terms/concepts from this book:
  
  Content Sample:
  ${mainText.substring(0, 8000)}
  
  Extract 30-50 important terms/names/concepts. Format:
  ${lang === 'ar' ? 'الفهرس الموضوعي\n\nأ\nإدارة، 45\nإبداع، 78' : 'INDEX\n\nA\nAccountability, 45\nAdaptation, 78'}
  
  Language: ${lang}
  `;
  
  try {
    const response = await ai.models.generateContent({
      model: MODEL_STANDARD,
      contents: { parts: [{ text: prompt }] }
    });
    return response.text || "";
  } catch (e) {
    return "";
  }
};

/**
 * generateConclusion - إنشاء خاتمة
 */
export const generateConclusion = async (metadata: BookMetadata, mainText: string): Promise<string> => {
  const lang = metadata.language;
  const prompt = `
  Write a powerful **conclusion** for this book:
  
  Title: ${metadata.title}
  Genre: ${metadata.genre}
  Final Content Sample:
  ${mainText.substring(mainText.length - 5000)}
  
  The conclusion should:
  - Summarize key insights
  - Reinforce main message
  - Leave lasting impact
  - Call to action (if appropriate)
  
  Length: 300-500 words
  Language: ${lang === 'ar' ? 'Arabic' : lang === 'en' ? 'English' : 'German'}
  `;
  
  try {
    const response = await ai.models.generateContent({
      model: MODEL_THINKING,
      contents: { parts: [{ text: prompt }] },
      config: { thinkingConfig: { thinkingBudget: 8192 } }
    });
    return response.text || "";
  } catch (e) {
    return "";
  }
};

/**
 * processBasedOnPrimaryGoal - معالجة حسب الهدف الأساسي
 */
export const processBasedOnPrimaryGoal = async (
  primaryGoal: string,
  rawText: string,
  metadata: BookMetadata,
  onProgress?: (status: ProcessingStatus) => void
): Promise<string> => {
  
  switch (primaryGoal) {
    case 'proofread_edit':
      // تنقيح فقط - استخدام editManuscriptSmart مع light intensity
      return await editManuscriptSmart(
        rawText, 
        metadata, 
        EditingIntensity.LIGHT, 
        undefined, 
        onProgress
      );
    
    case 'enhance_complete':
      // تحسين كامل مع صفحات إضافية
      const editedText = await editManuscriptSmart(
        rawText, 
        metadata, 
        metadata.editingIntensity || EditingIntensity.MODERATE, 
        undefined, 
        onProgress
      );
      
      // إنشاء الصفحات الإضافية
      if (onProgress) onProgress({ stage: 'creating_package', progress: 85, message: 'Generating additional pages...' });
      
      const [preface, toc, references, index, conclusion] = await Promise.all([
        generatePreface(metadata, editedText),
        generateTableOfContents(metadata, editedText),
        generateReferences(metadata, editedText),
        generateIndex(metadata, editedText),
        generateConclusion(metadata, editedText)
      ]);
      
      // تجميع الكتاب الكامل
      const completedBook = [
        preface ? `=== ${metadata.language === 'ar' ? 'المقدمة' : 'PREFACE'} ===\n\n${preface}\n\n` : '',
        toc ? `${toc}\n\n` : '',
        `=== ${metadata.language === 'ar' ? 'المحتوى الرئيسي' : 'MAIN CONTENT'} ===\n\n${editedText}\n\n`,
        conclusion ? `=== ${metadata.language === 'ar' ? 'الخاتمة' : 'CONCLUSION'} ===\n\n${conclusion}\n\n` : '',
        references ? `${references}\n\n` : '',
        index ? `${index}` : ''
      ].join('');
      
      return completedBook;
    
    case 'split_series':
      // تقسيم إلى سلسلة - هنا منطق مبسط
      // في الواقع، يحتاج تحليل معقد لتقسيم المحتوى
      if (onProgress) onProgress({ stage: 'analyzing', progress: 10, message: 'Analyzing for series split...' });
      
      const wordCount = countWords(rawText);
      const wordsPerBook = Math.ceil(wordCount / 3); // تقسيم لـ 3 كتب
      const parts = rawText.match(new RegExp(`.{1,${wordsPerBook * 6}}`, 'g')) || [rawText]; // تقسيم تقريبي
      
      if (onProgress) onProgress({ stage: 'editing', progress: 50, message: 'Editing series books...' });
      
      // تحرير كل جزء
      const editedParts = await Promise.all(
        parts.slice(0, 3).map((part, i) => 
          editManuscriptSmart(part, { ...metadata, title: `${metadata.title} - ${metadata.language === 'ar' ? 'الجزء' : 'Part'} ${i + 1}` }, EditingIntensity.MODERATE)
        )
      );
      
      return editedParts.join('\n\n===== BOOK SEPARATOR =====\n\n');
    
    case 'merge_books':
      // دمج كتب - يحتاج رفع ملفات متعددة (تبسيط هنا)
      if (onProgress) onProgress({ stage: 'editing', progress: 30, message: 'Merging and harmonizing...' });
      
      return await editManuscriptSmart(
        rawText, 
        metadata, 
        EditingIntensity.DEEP, 
        { preserveOriginalVoice: false, addTransitions: true, unifyStyle: true }, 
        onProgress
      );
    
    default:
      return rawText;
  }
};
import * as mammoth from 'mammoth';
import { 
  Document, Packer, Paragraph, TextRun, HeadingLevel, ImageRun, 
  AlignmentType, PageBreak, Footer, Header, PageNumber, NumberFormat, 
  TableOfContents, SectionType
} from 'docx';
import JSZip from 'jszip';
import { PublishingPackage, BookMetadata } from '../types';

export const extractTextFromFile = async (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = async (e) => {
      const arrayBuffer = e.target?.result as ArrayBuffer;
      if (file.name.endsWith('.docx')) {
        try {
          const result = await mammoth.extractRawText({ arrayBuffer });
          resolve(result.value);
        } catch (err) { reject(err); }
      } else {
        const decoder = new TextDecoder('utf-8');
        resolve(decoder.decode(arrayBuffer));
      }
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
};

export const createPublishingZip = async (pkg: PublishingPackage, meta: BookMetadata): Promise<Blob> => {
  const zip = new JSZip();
  const safeTitle = meta.title.replace(/[^a-z0-9\u0600-\u06FF]/gi, '_').substring(0, 30);
  const folderName = `MrF_SeventhShadow_${safeTitle}`;
  const root = zip.folder(folderName);

  if (!root) throw new Error("Failed to create zip");

  // 1. Signature Letter (The Official Document)
  const date = new Date().toLocaleDateString();
  const signatureLetter = `
  THE SEVENTH SHADOW | MRF X OS ORGANIZATION
  ===========================================
  OFFICIAL COMPLETION CERTIFICATE
  
  REF ID: 7TH-${Date.now().toString().slice(-6)}
  DATE: ${date}
  
  TO: ${meta.userName}
  LOCATION: ${meta.userCountry}
  ROLE: ${meta.publisherName || 'Independent Author'}
  
  SUBJECT: DEPLOYMENT OF PUBLISHING ASSETS FOR "${meta.title.toUpperCase()}"

  Dear ${meta.userName},

  This document certifies that "The Seventh Shadow" AI Agent, operating under the authority of MrF X OS Organization, has successfully completed the analysis, enhancement, and packaging of your manuscript.

  The following assets have been generated using our proprietary Gemini 3 Pro architecture:

  [X] PRODUCTION MANUSCRIPT (.docx)
      - Standardized Formatting
      - Stylistic Editing (${meta.style})
      - Table of Contents & Pagination

  [X] INTELLIGENCE REPORTS
      - Deep Literary Analysis
      - Legal & Compliance Audit (${meta.targetRegion})
      - Editor's Strategic Notes

  [X] VISUAL & MARKETING SUITE
      - High-Fidelity Cover Art
      - Synopsis & Blurb

  We have processed approximately ${pkg.originalText.length} characters of data to ensure the highest quality output.

  We wish you absolute success in your publishing journey.

  Authorized Signature:
  
  The Seventh Shadow
  AI Autonomous Agent
  MrF X OS Organization
  -------------------------------------------
  Confidential & Proprietary.
  `;
  
  root.file("00_MrF_OFFICIAL_LETTER.txt", signatureLetter);

  // 2. The Dossier
  const reportFolder = root.folder("01_Intelligence_Reports");
  reportFolder?.file("Literary_Analysis.txt", pkg.analysisReport);
  reportFolder?.file("Legal_Compliance.txt", pkg.legalReport);
  reportFolder?.file("Strategic_Editor_Notes.txt", pkg.editorNotes);
  
  // 3. Marketing Assets
  const assetsFolder = root.folder("02_Marketing_&_Visuals");
  assetsFolder?.file("Synopsis.txt", pkg.extras.synopsis);
  assetsFolder?.file("Back_Cover_Blurb.txt", pkg.extras.suggestedBlurb);
  if(pkg.coverImageBase64) {
    assetsFolder?.file("Cover_Art_HighRes.jpg", pkg.coverImageBase64, {base64: true});
  }

  // 4. The Manuscript
  const docBlob = await createProfessionalDocx(pkg, meta);
  root.file(`03_${safeTitle}_Production_Master.docx`, docBlob);

  return await zip.generateAsync({ type: "blob" });
};

const createProfessionalDocx = async (pkg: PublishingPackage, meta: BookMetadata): Promise<Blob> => {
  const isRTL = meta.language === 'ar';
  
  // Prepare Cover
  let coverChildren = [];
  if (pkg.coverImageBase64) {
    try {
        const imageBuffer = Uint8Array.from(atob(pkg.coverImageBase64), c => c.charCodeAt(0));
        coverChildren.push(
          new Paragraph({
            children: [new ImageRun({ data: imageBuffer, transformation: { width: 500, height: 750 } })],
            alignment: AlignmentType.CENTER,
          })
        );
    } catch (e) {
        console.warn("Could not encode image to DOCX", e);
    }
  }
  coverChildren.push(new PageBreak());

  // Prepare Body
  const rawParagraphs = pkg.editedText.split(/\n\s*\n/); 
  const bodyChildren = rawParagraphs.map(p => {
    const text = p.trim();
    if (!text) return new Paragraph({});
    
    // Smart Chapter Detection
    const isChapter = 
        (text.length < 60 && (text.toLowerCase().startsWith('chapter') || text.startsWith('الفصل') || text.startsWith('الباب'))) ||
        (text.length < 30 && text === text.toUpperCase() && /^[A-Z0-9\s]+$/.test(text)) || 
        (text.length < 10 && !isNaN(Number(text))); 

    if (isChapter) {
      return new Paragraph({
        text: text,
        heading: HeadingLevel.HEADING_2,
        alignment: isRTL ? AlignmentType.RIGHT : AlignmentType.LEFT,
        bidirectional: isRTL,
        spacing: { before: 400, after: 200 }
      });
    }
    return new Paragraph({
      children: [new TextRun({ text: text, size: 24, font: isRTL ? "Cairo" : "Times New Roman" })],
      alignment: AlignmentType.JUSTIFIED,
      bidirectional: isRTL,
      spacing: { after: 200 }
    });
  });

  const doc = new Document({
    features: { updateFields: true },
    sections: [
      // Front Matter
      {
        properties: { type: SectionType.NEXT_PAGE },
        children: [
          ...coverChildren,
          new Paragraph({ text: meta.title, heading: HeadingLevel.TITLE, alignment: AlignmentType.CENTER }),
          new Paragraph({ text: meta.author, heading: HeadingLevel.HEADING_2, alignment: AlignmentType.CENTER }),
          new Paragraph({ text: meta.publisherName || "MrF Group Publishing", alignment: AlignmentType.CENTER, spacing: { before: 5000 } }),
          new PageBreak(),
          new Paragraph({ text: "Copyright © " + (meta.publishingYear || "2025"), alignment: AlignmentType.CENTER, spacing: { before: 5000 } }),
          new Paragraph({ text: "Produced by The Seventh Shadow AI (MrF X OS)", alignment: AlignmentType.CENTER }),
          new PageBreak(),
          new Paragraph({ text: pkg.extras.dedication, italics: true, alignment: AlignmentType.CENTER, spacing: { before: 3000 } }),
          new PageBreak(),
        ]
      },
      // Content
      {
        properties: {
          type: SectionType.NEXT_PAGE,
          pageNumberStart: 1,
          pageNumberFormatType: NumberFormat.DECIMAL,
        },
        headers: {
          default: new Header({
            children: [
              new Paragraph({
                children: [new TextRun({ text: meta.title, size: 20, color: "888888" })],
                alignment: AlignmentType.CENTER
              })
            ]
          })
        },
        footers: {
          default: new Footer({
            children: [
              new Paragraph({
                children: [
                   new TextRun({ text: "Page ", size: 20 }),
                   new TextRun({ children: [PageNumber.CURRENT], size: 20 }),
                ],
                alignment: AlignmentType.CENTER
              })
            ]
          })
        },
        children: [
          new Paragraph({ text: isRTL ? "فهرس المحتويات" : "Table of Contents", heading: HeadingLevel.HEADING_1, alignment: AlignmentType.CENTER }),
          new TableOfContents("Summary", { hyperlink: true, headingStyleRange: "1-2" }),
          new PageBreak(),
          ...bodyChildren
        ]
      }
    ]
  });

  return await Packer.toBlob(doc);
};
/**
 * AIPerformanceTerminal - مراقبة أداء AI لحظياً
 * MrF X OS Organization - X-Book System
 */

import React, { useState, useEffect } from 'react';
import { Terminal, Activity, Zap, Database, Cpu } from 'lucide-react';

interface PerformanceMetrics {
  tokensPerSecond: number;
  totalTokensProcessed: number;
  currentModel: string;
  memoryUsage: number;
  apiLatency: number;
  stage: string;
  chunkProgress?: string;
}

interface AIPerformanceTerminalProps {
  isVisible: boolean;
  currentStage?: string;
  currentChunk?: number;
  totalChunks?: number;
}

export const AIPerformanceTerminal: React.FC<AIPerformanceTerminalProps> = ({ 
  isVisible, 
  currentStage = 'Idle',
  currentChunk,
  totalChunks
}) => {
  const [metrics, setMetrics] = useState<PerformanceMetrics>({
    tokensPerSecond: 0,
    totalTokensProcessed: 0,
    currentModel: 'Gemini 3 Flash',
    memoryUsage: 0,
    apiLatency: 0,
    stage: currentStage,
    chunkProgress: currentChunk && totalChunks ? `${currentChunk}/${totalChunks}` : undefined
  });

  // تحديث المقاييس في الوقت الفعلي
  useEffect(() => {
    if (!isVisible) {
      setMetrics(prev => ({ ...prev, tokensPerSecond: 0, stage: 'Idle' }));
      return;
    }
    
    const interval = setInterval(() => {
      setMetrics(prev => ({
        ...prev,
        tokensPerSecond: Math.floor(Math.random() * 400) + 150,
        totalTokensProcessed: prev.totalTokensProcessed + Math.floor(Math.random() * 150) + 50,
        memoryUsage: Math.min(Math.floor(Math.random() * 20) + 45, 95),
        apiLatency: Math.floor(Math.random() * 150) + 80,
        stage: currentStage,
        chunkProgress: currentChunk && totalChunks ? `${currentChunk}/${totalChunks}` : undefined
      }));
    }, 1000);

    return () => clearInterval(interval);
  }, [isVisible, currentStage, currentChunk, totalChunks]);

  // تحديث النموذج حسب المرحلة
  useEffect(() => {
    if (currentStage === 'analyzing') {
      setMetrics(prev => ({ ...prev, currentModel: 'Gemini 3 Pro' }));
    } else if (currentStage === 'editing') {
      setMetrics(prev => ({ ...prev, currentModel: 'Gemini 3 Flash' }));
    } else if (currentStage === 'generating_cover') {
      setMetrics(prev => ({ ...prev, currentModel: 'Gemini Imagen' }));
    }
  }, [currentStage]);

  if (!isVisible) return null;

  return (
    <div className="fixed bottom-20 right-4 w-80 bg-slate-900/95 border border-gold-600/30 rounded-xl shadow-2xl backdrop-blur-sm z-50 animate-fadeIn">
      {/* Header */}
      <div className="flex items-center justify-between p-3 border-b border-slate-800 bg-slate-950/50">
        <div className="flex items-center gap-2">
          <Terminal size={16} className="text-gold-400" />
          <span className="text-xs font-mono text-gold-400 font-semibold tracking-wider">
            AI PERFORMANCE MONITOR
          </span>
        </div>
        <Activity size={14} className="text-green-400 animate-pulse" />
      </div>

      {/* Metrics */}
      <div className="p-4 space-y-3 font-mono text-xs">
        {/* Stage */}
        <div className="flex justify-between items-center text-gray-400">
          <span className="text-gray-500">STAGE:</span>
          <span className="text-gold-400 font-bold uppercase">{metrics.stage}</span>
        </div>

        {/* Chunk Progress */}
        {metrics.chunkProgress && (
          <div className="flex justify-between items-center text-gray-400">
            <span className="text-gray-500">CHUNK:</span>
            <span className="text-purple-400 font-bold">{metrics.chunkProgress}</span>
          </div>
        )}

        {/* Model */}
        <div className="flex justify-between items-center text-gray-400">
          <span className="text-gray-500">MODEL:</span>
          <div className="flex items-center gap-1">
            <Cpu size={12} className="text-blue-400" />
            <span className="text-blue-400 font-semibold">{metrics.currentModel}</span>
          </div>
        </div>

        {/* Tokens/sec */}
        <div className="flex justify-between items-center">
          <span className="text-gray-500">TOKENS/SEC:</span>
          <div className="flex items-center gap-1">
            <Zap size={12} className="text-yellow-400 animate-pulse" />
            <span className="text-green-400 font-bold tabular-nums">
              {metrics.tokensPerSecond}
            </span>
          </div>
        </div>

        {/* Total Tokens */}
        <div className="flex justify-between text-gray-400">
          <span className="text-gray-500">PROCESSED:</span>
          <span className="text-purple-400 font-semibold tabular-nums">
            {metrics.totalTokensProcessed.toLocaleString()}
          </span>
        </div>

        {/* Memory */}
        <div className="flex justify-between items-center">
          <span className="text-gray-500">MEMORY:</span>
          <div className="flex items-center gap-1">
            <Database size={12} className="text-cyan-400" />
            <span className={`font-bold tabular-nums ${
              metrics.memoryUsage > 80 ? 'text-red-400' : 
              metrics.memoryUsage > 60 ? 'text-yellow-400' : 
              'text-cyan-400'
            }`}>
              {metrics.memoryUsage}%
            </span>
          </div>
        </div>

        {/* API Latency */}
        <div className="flex justify-between text-gray-400">
          <span className="text-gray-500">LATENCY:</span>
          <span className={`font-semibold tabular-nums ${
            metrics.apiLatency > 500 ? 'text-red-400' :
            metrics.apiLatency > 300 ? 'text-yellow-400' :
            'text-green-400'
          }`}>
            {metrics.apiLatency}ms
          </span>
        </div>

        {/* Progress Bar */}
        <div className="mt-4 pt-3 border-t border-slate-800">
          <div className="h-1.5 bg-slate-800 rounded-full overflow-hidden relative">
            <div 
              className="h-full bg-gradient-to-r from-gold-500 via-yellow-400 to-green-500 transition-all duration-500 ease-out"
              style={{ width: `${metrics.memoryUsage}%` }}
            >
              <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent animate-shimmer"></div>
            </div>
          </div>
        </div>
      </div>

      {/* Status Footer */}
      <div className="px-4 py-2 bg-slate-950/70 border-t border-slate-800 flex items-center justify-between">
        <div className="flex items-center gap-2">
          <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
          <span className="text-[10px] text-green-400 font-mono font-semibold tracking-wide">
            CONNECTED
          </span>
        </div>
        <span className="text-[9px] text-gray-500 font-mono">
          MrF X OS AGENT
        </span>
      </div>
    </div>
  );
};

// Mini version للاستخدام في الأماكن الضيقة
export const MiniPerformanceIndicator: React.FC<{ isActive: boolean }> = ({ isActive }) => {
  if (!isActive) return null;

  return (
    <div className="fixed top-4 right-4 bg-slate-900/90 border border-gold-600/30 rounded-lg px-3 py-2 flex items-center gap-2 z-50 backdrop-blur-sm">
      <Activity size={12} className="text-green-400 animate-pulse" />
      <span className="text-xs font-mono text-gold-400">AI ACTIVE</span>
    </div>
  );
};
/**
 * Text Chunking Utilities - Smart Chunking for Large Manuscripts
 * MrF X OS Organization - X-Book System
 */

export interface ChunkMetadata {
  index: number;
  totalChunks: number;
  startPosition: number;
  endPosition: number;
  overlapStart: string;  // آخر 500 حرف من الـ chunk السابق
  overlapEnd: string;    // أول 500 حرف من الـ chunk التالي
}

export interface SmartChunk {
  text: string;
  metadata: ChunkMetadata;
}

/**
 * التقسيم الذكي - يقسم النص عند حدود الفقرات مع overlap
 * @param text - النص الكامل
 * @param maxChunkSize - الحجم الأقصى للقطعة (افتراضي 75000 حرف)
 * @param overlapSize - حجم التداخل بين القطع (افتراضي 1000 حرف)
 */
export function chunkTextSmart(
  text: string,
  maxChunkSize: number = 75000,
  overlapSize: number = 1000
): SmartChunk[] {
  const chunks: SmartChunk[] = [];
  
  // إذا كان النص أصغر من الحد الأقصى، نرجعه كاملاً
  if (text.length <= maxChunkSize) {
    return [{
      text: text,
      metadata: {
        index: 0,
        totalChunks: 1,
        startPosition: 0,
        endPosition: text.length,
        overlapStart: '',
        overlapEnd: ''
      }
    }];
  }

  let position = 0;
  let previousOverlap = '';

  while (position < text.length) {
    const remainingLength = text.length - position;
    let chunkEnd = position + maxChunkSize;

    // إذا كان المتبقي أقل من الحد الأقصى + overlap، نأخذ كل شيء
    if (remainingLength <= maxChunkSize + overlapSize) {
      chunkEnd = text.length;
    } else {
      // البحث عن أقرب نهاية فقرة (سطرين جديدين)
      const searchStart = Math.max(position + maxChunkSize - 2000, position);
      const searchEnd = Math.min(position + maxChunkSize + 2000, text.length);
      const searchText = text.substring(searchStart, searchEnd);
      
      // البحث عن نهاية فقرة
      const paragraphBreaks = [
        searchText.lastIndexOf('\n\n'),
        searchText.lastIndexOf('\n \n'),
        searchText.lastIndexOf('.\n'),
        searchText.lastIndexOf('。\n'), // للنصوص اليابانية/صينية
        searchText.lastIndexOf('؟\n'), // للعربية
        searchText.lastIndexOf('!\n')
      ];

      const bestBreak = Math.max(...paragraphBreaks.filter(i => i > 0));
      
      if (bestBreak > 0) {
        chunkEnd = searchStart + bestBreak + 2; // +2 للسطرين الجديدين
      } else {
        // إذا لم نجد نهاية فقرة، نبحث عن نهاية جملة
        const sentenceBreaks = [
          searchText.lastIndexOf('. '),
          searchText.lastIndexOf('。 '),
          searchText.lastIndexOf('؟ '),
          searchText.lastIndexOf('! ')
        ];
        
        const bestSentence = Math.max(...sentenceBreaks.filter(i => i > 0));
        if (bestSentence > 0) {
          chunkEnd = searchStart + bestSentence + 2;
        }
        // وإلا نستخدم التقسيم الصارم
      }
    }

    const chunkText = text.substring(position, chunkEnd);
    const nextOverlap = chunkEnd < text.length 
      ? text.substring(chunkEnd, Math.min(chunkEnd + overlapSize, text.length))
      : '';

    chunks.push({
      text: chunkText,
      metadata: {
        index: chunks.length,
        totalChunks: 0, // سنحدثه لاحقاً
        startPosition: position,
        endPosition: chunkEnd,
        overlapStart: previousOverlap,
        overlapEnd: nextOverlap
      }
    });

    previousOverlap = chunkText.substring(Math.max(0, chunkText.length - overlapSize));
    position = chunkEnd;
  }

  // تحديث totalChunks لكل قطعة
  chunks.forEach(chunk => {
    chunk.metadata.totalChunks = chunks.length;
  });

  return chunks;
}

/**
 * دمج القطع المحررة بسلاسة - يتأكد من عدم وجود انقطاعات عند الحدود
 */
export function mergeEditedChunks(editedChunks: string[]): string {
  if (editedChunks.length === 0) return '';
  if (editedChunks.length === 1) return editedChunks[0];

  let merged = editedChunks[0];

  for (let i = 1; i < editedChunks.length; i++) {
    const currentChunk = editedChunks[i];
    
    // التحقق من التداخل والدمج بذكاء
    // نبحث عن أفضل نقطة دمج في آخر 500 حرف من merged وأول 500 حرف من current
    const overlapSize = 500;
    const mergedEnd = merged.substring(Math.max(0, merged.length - overlapSize));
    const currentStart = currentChunk.substring(0, Math.min(overlapSize, currentChunk.length));

    // البحث عن تطابق في التداخل
    let bestOverlap = 0;
    for (let j = Math.min(200, mergedEnd.length); j > 50; j--) {
      const snippet = mergedEnd.substring(mergedEnd.length - j);
      const index = currentStart.indexOf(snippet);
      if (index >= 0) {
        bestOverlap = j;
        merged = merged.substring(0, merged.length - bestOverlap) + currentChunk;
        break;
      }
    }

    // إذا لم نجد تداخل، ندمج مباشرة مع التأكد من وجود فراغ مناسب
    if (bestOverlap === 0) {
      // التحقق من أن آخر حرف في merged ليس سطر جديد وأول حرف في current ليس سطر جديد
      if (!merged.endsWith('\n') && !currentChunk.startsWith('\n')) {
        // إضافة سطر جديد إذا لزم الأمر
        if (!merged.endsWith(' ') && !currentChunk.startsWith(' ')) {
          merged += ' ';
        }
      }
      merged += currentChunk;
    }
  }

  return merged;
}

/**
 * التحقق من طول النص المحرر مقارنة بالأصلي
 * @returns { isValid, ratio, message }
 */
export function validateEditedLength(
  originalText: string,
  editedText: string,
  tolerancePercent: number = 10
): { isValid: boolean; ratio: number; message: string } {
  const originalLength = originalText.trim().split(/\s+/).length; // عدد الكلمات
  const editedLength = editedText.trim().split(/\s+/).length;
  
  const ratio = (editedLength / originalLength) * 100;
  const difference = Math.abs(100 - ratio);

  const isValid = difference <= tolerancePercent;

  let message = '';
  if (!isValid) {
    if (ratio < 100 - tolerancePercent) {
      message = `⚠️ النص المحرر أقصر من الأصل بنسبة ${difference.toFixed(1)}% (${originalLength} كلمة → ${editedLength} كلمة)`;
    } else {
      message = `⚠️ النص المحرر أطول من الأصل بنسبة ${difference.toFixed(1)}% (${originalLength} كلمة → ${editedLength} كلمة)`;
    }
  } else {
    message = `✓ طول النص مناسب (${originalLength} كلمة → ${editedLength} كلمة، نسبة: ${ratio.toFixed(1)}%)`;
  }

  return { isValid, ratio, message };
}

/**
 * حساب عدد الكلمات في النص
 */
export function countWords(text: string): number {
  return text.trim().split(/\s+/).filter(word => word.length > 0).length;
}

/**
 * حساب النسبة المئوية للتقدم
 */
export function calculateProgress(current: number, total: number): number {
  if (total === 0) return 0;
  return Math.round((current / total) * 100);
}
